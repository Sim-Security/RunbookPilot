# RunbookPilot

[![CI](https://github.com/Sim-Security/RunbookPilot/actions/workflows/ci.yml/badge.svg)](https://github.com/Sim-Security/RunbookPilot/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Bun](https://img.shields.io/badge/runtime-Bun-f9f1e1.svg)](https://bun.sh)
[![TypeScript](https://img.shields.io/badge/language-TypeScript-3178c6.svg)](https://www.typescriptlang.org/)

**AI-assisted SOC runbook automation with graduated autonomy (L0/L1/L2).** RunbookPilot bridges the gap between manual incident response checklists and fully autonomous SOAR platforms by providing a deterministic state machine for runbook execution with LLM-powered enrichment. It operationalizes detection rules (including those generated by [DetectForge](https://github.com/Sim-Security/DetectForge)) into executable response workflows — safely, transparently, and with mandatory human-in-the-loop controls.

## Key Features

- **Graduated Autonomy** — Three automation levels: L0 (manual checklist), L1 (semi-auto with approval gates), L2 (simulation-only in v1)
- **Deterministic Execution** — Pure state machine engine with no LLM in the decision path. Predictable, auditable, reproducible
- **LLM Enrichment** — OpenRouter-powered investigation summaries, ATT&CK context, and next-step suggestions (never decisions)
- **Approval Gates** — Mandatory approval for write operations with full context display and configurable timeouts
- **Mandatory Rollback** — Every write action must define a rollback procedure. One-click undo for false positives
- **Vendor Agnostic** — Adapter pattern for any EDR, SIEM, firewall, or ticketing system
- **ECS Native** — Elastic Common Schema for alert ingestion, ATT&CK technique IDs for playbook matching
- **DetectForge Integration** — Native support for `x-detectforge` Sigma metadata, forming a detection-to-response pipeline
- **Full Audit Trail** — Append-only audit log with SHA-256 hash chain for tamper detection

## Quick Start

### Prerequisites

- [Bun](https://bun.sh) v1.0+ (runtime)
- Node.js 18+ (for vitest test runner)
- Git

### Install

```bash
git clone https://github.com/Sim-Security/RunbookPilot.git
cd RunbookPilot
bun install
```

### Configure

```bash
cp .env.example .env
# Edit .env with your settings (OpenRouter API key, etc.)
```

### Run

```bash
# Validate a playbook
bun run cli validate playbooks/lsass-credential-dumping-l0.yml

# List available playbooks
bun run cli list

# Execute a playbook with a test alert
echo '{"event":{"kind":"alert","category":["intrusion_detection"]},"threat":{"technique":{"id":["T1003.001"]}}}' | bun run cli run --playbook lsass-credential-dumping-l0

# Search playbooks by ATT&CK technique
bun run cli search --technique T1021.002
```

## CLI Commands

| Command | Description | Example |
|---------|-------------|---------|
| `run` | Execute a playbook against an alert | `bun run cli run --playbook <id> [--level L0\|L1\|L2]` |
| `validate` | Validate playbook YAML schema | `bun run cli validate playbooks/*.yml` |
| `list` | List all available playbooks | `bun run cli list [--format json]` |
| `show` | Show playbook details | `bun run cli show <playbook-id>` |
| `search` | Search playbooks by technique/tag | `bun run cli search --technique T1003.001` |
| `queue` | Manage the L2 simulation queue | `bun run cli queue list` |
| `metrics` | View execution metrics and stats | `bun run cli metrics [--format json]` |

## Automation Levels

| Level | Name | Behavior | Approval |
|-------|------|----------|----------|
| **L0** | Manual | Interactive checklist — analyst performs all actions, RunbookPilot tracks progress | Never required |
| **L1** | Semi-Auto | Read-only enrichment runs automatically; write actions require explicit approval | Required for writes |
| **L2** | Simulation | Full action plan generated in dry-run mode — no real execution in v1 | Simulation auto-runs; execution requires approval |

### Autonomy Progression

```
L0 (Week 1-4)     L1 (Week 5-8)           L2 (Week 9+)
Manual checklists → Auto-enrichment +     → Simulate full response,
                    approval-gated writes    one-click execute
```

## Reference Playbooks

| Playbook | Level | ATT&CK Technique | Description |
|----------|-------|-------------------|-------------|
| `lsass-credential-dumping-l0` | L0 | T1003.001 | Guided investigation of LSASS credential dumping |
| `wmi-lateral-movement-l1` | L1 | T1047, T1021.002 | Automated enrichment + approval-gated host containment |
| `cobalt-strike-c2-l2` | L2 | T1071.001, T1573 | Full C2 beaconing response simulation |
| `examples/basic` | L0 | — | Example phishing email investigation |

## Configuration

RunbookPilot is configured via environment variables (`.env` file). Key settings:

| Variable | Default | Description |
|----------|---------|-------------|
| `AUTOMATION_LEVEL` | `L0` | Default automation level (L0/L1/L2) |
| `OPENROUTER_API_KEY` | — | API key for LLM enrichment ([get one](https://openrouter.ai/keys)) |
| `OPENROUTER_MODEL_FAST` | `x-ai/grok-4.1-fast` | Model for quick enrichment tasks |
| `OPENROUTER_MODEL_STANDARD` | `moonshotai/kimi-k2.5` | Model for analysis and investigation |
| `OPENROUTER_MODEL_QUALITY` | `google/gemini-3-flash-preview` | Model for complex reasoning and reports |
| `RUNBOOKPILOT_DB_PATH` | `./data/runbookpilot.db` | SQLite database path |
| `PLAYBOOK_DIRS` | `./playbooks` | Playbook search directories |
| `LOG_LEVEL` | `info` | Log verbosity (trace/debug/info/warn/error/fatal) |
| `SERVER_PORT` | `3000` | Webhook server port |
| `APPROVAL_TIMEOUT` | `3600` | Approval gate timeout in seconds |
| `MAX_EXECUTION_TIME` | `900` | Max runbook execution time in seconds |

LLM enrichment is optional — RunbookPilot runs in deterministic-only mode when `OPENROUTER_API_KEY` is not set.

## Development

### Testing

```bash
# Run all tests
bun run test

# Run tests in watch mode
bun run test:watch

# Run tests with coverage
bun run test:coverage

# Type checking
bun run typecheck
```

**Test stats:** 1,731 tests across 46 test files. Coverage thresholds: 80% lines, statements, branches, and functions.

### Project Structure

```
src/
  cli/              # Commander.js CLI commands
  engine/           # Execution engine, state machine, L0/L1/L2 executors
    executors/      # Level-specific execution logic
  ingest/           # Alert ingestion (STDIN, webhook, file)
  llm/              # OpenRouter LLM integration
  adapters/         # Vendor-agnostic action adapters
  playbook/         # YAML parser, schema validator, playbook matcher
  storage/          # SQLite repositories (executions, audit, approvals)
  metrics/          # Execution metrics and dashboard data
  types/            # TypeScript type definitions (Zod schemas)
tests/              # Vitest test suites (mirrors src/ structure)
playbooks/          # YAML playbook definitions
docs/               # Architecture, PRD, sprint backlog, technical reference
```

### Key Technologies

| Technology | Purpose |
|-----------|---------|
| [Bun](https://bun.sh) | TypeScript runtime |
| [Vitest](https://vitest.dev) | Test framework |
| [Commander.js](https://github.com/tj/commander.js) | CLI framework |
| [SQLite](https://www.sqlite.org/) (via better-sqlite3) | Storage (executions, audit log, approvals) |
| [Zod](https://zod.dev) | Schema validation |
| [OpenRouter](https://openrouter.ai) | LLM gateway (model-agnostic) |
| [Pino](https://getpino.io) | Structured logging |

## Docker

### Build

```bash
docker build -t runbookpilot .
```

### Run with Docker Compose

```bash
# Copy and configure environment
cp .env.example .env

# Start RunbookPilot
docker-compose up -d
```

### DetectForge Integration (Full Pipeline)

```bash
# Start the full detection-to-response pipeline
docker-compose -f docker-compose.integration.yml up -d
```

This starts both DetectForge and RunbookPilot, demonstrating the complete workflow: threat intel report → detection rule generation → alert ingestion → automated response.

## Architecture

RunbookPilot follows a layered architecture with strict separation of concerns:

```
Alert Ingestion (STDIN / Webhook / File)
        │
        ▼
  ECS Normalizer → Playbook Matcher (ATT&CK / Tags)
        │
        ▼
  Execution Engine (Deterministic State Machine)
    ├── L0 Executor (manual checklist)
    ├── L1 Executor (auto-enrich + approval gates)
    └── L2 Executor (simulation only)
        │
        ▼
  Action Adapter Layer (EDR / SIEM / Firewall / Ticketing)
        │
        ▼
  Cross-Cutting: Audit Logger │ LLM Assistant │ Metrics │ Approval Queue
```

**Core principle:** The execution engine is a pure state machine. LLMs assist analysts but never make security decisions.

For the full architecture document, see [`docs/ARCHITECTURE.md`](docs/ARCHITECTURE.md).

## DetectForge Integration

RunbookPilot natively integrates with [DetectForge](https://github.com/Sim-Security/DetectForge) to form a complete **detection-to-response pipeline**:

1. **DetectForge** generates Sigma/YARA/Suricata detection rules from threat intelligence
2. Rules deployed to SIEM trigger alerts on match
3. **RunbookPilot** ingests alerts via webhook, extracts ATT&CK techniques
4. Playbooks auto-selected via `x-detectforge` metadata or technique matching
5. Response executed at configured automation level (L0/L1/L2)

```yaml
# DetectForge Sigma rule with RunbookPilot integration
x-detectforge:
  suggested_runbook: wmi-lateral-movement-l1
  confidence: high
  techniques: [T1047, T1021.002]
```

RunbookPilot works fully standalone — DetectForge is not required.

## License

[MIT](LICENSE)

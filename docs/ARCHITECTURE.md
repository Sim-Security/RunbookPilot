# RunbookPilot Architecture Document

**Version:** 1.0
**Last Updated:** 2026-02-10
**Status:** Design Document

---

## 1. Overview

### 1.1 System Purpose

RunbookPilot is an open-source, AI-assisted SOC runbook automation platform with graduated autonomy and mandatory human-in-the-loop controls. It bridges the gap between manual incident response checklists and fully autonomous SOAR platforms by providing three distinct automation levels:

- **L0 (Manual):** Interactive checklist mode for analyst-driven investigation
- **L1 (Semi-Auto):** Automated read-only enrichment with approval-gated write operations
- **L2 (Simulation):** Full action plan generation in dry-run mode with one-click approval (no auto-execution in v1)

RunbookPilot is designed to operationalize detection rules generated by DetectForge, forming a complete detection-to-response pipeline for modern SOC operations.

### 1.2 Positioning

**What RunbookPilot Is:**
- A deterministic state machine for runbook execution
- An LLM-assisted analyst co-pilot for investigation workflows
- A simulation engine for safe testing of response actions
- A vendor-agnostic integration layer for security tools

**What RunbookPilot Is NOT:**
- An autonomous AI agent that makes security decisions
- A replacement for SIEM correlation engines
- A machine learning-based anomaly detection system
- A ticketing system (integrates with existing ones)

### 1.3 Core Value Proposition

1. **Safety-First Automation:** Approval gates and rollback definitions are mandatory, not optional
2. **Transparent Decision-Making:** All actions logged with full context and approval chain
3. **Gradual Autonomy:** Start with L0 checklists, graduate to L1 enrichment, simulate L2 responses
4. **Vendor Agnostic:** Works with any EDR, SIEM, or security tool via adapters
5. **DetectForge Integration:** Native support for Sigma/YARA/Suricata detections with ATT&CK mapping

---

## 2. Architecture Principles

### 2.1 Deterministic Execution

**Principle:** The execution engine is a pure state machine with no ML/LLM in the critical path.

**Rationale:** Security operations require predictable, auditable behavior. Non-deterministic AI models cannot be in the decision loop for actions that affect production systems.

**Implementation:**
- State transitions defined in YAML playbooks
- LLM used only for enrichment, summarization, and analyst assistance
- All automation decisions made by rule-based logic
- Execution paths reproducible from audit logs

### 2.2 Simulation-First L2

**Principle:** Build full L2 capability but run in dry-run mode only for v1.

**Rationale:** Demonstrates value of automation without risk. Builds trust through transparency. Collects data for future auto-execution validation.

**Implementation:**
- L2 engine generates complete action plans
- Actions logged as structured JSON instead of executed
- Approval queue stores simulated actions for review
- Metrics track simulation accuracy vs analyst decisions
- v2 can enable selective auto-execution based on confidence

### 2.3 Loose Coupling

**Principle:** Components communicate via standardized event formats and ATT&CK IDs.

**Rationale:** Enables integration with any detection source, SIEM, or security tool without tight dependencies.

**Implementation:**
- ECS (Elastic Common Schema) for alert ingestion
- ATT&CK technique IDs for detection-to-playbook mapping
- Adapter pattern for vendor integrations
- File-based handoff for DetectForge integration
- Webhook/STDIN for standalone mode

### 2.4 Approval Gates as First-Class Citizens

**Principle:** Approval requirements are defined in the playbook schema, not bolted on post-hoc.

**Rationale:** Security tools that add approval as an afterthought create approval fatigue and shadow operations. Explicit gates with context enable informed decisions.

**Implementation:**
- `approval_required` field at step level
- Approval queue with full execution context
- Role-based approval workflows (L1, L2, Admin)
- Time-bound approvals with auto-escalation
- Approval audit trail with justification capture

### 2.5 Rollback Mandatory

**Principle:** If you cannot define a rollback action, you cannot auto-execute the step.

**Rationale:** Forces playbook authors to think through failure modes and recovery. Enables safe experimentation and reduces fear of automation.

**Implementation:**
- `rollback` section required for all write operations
- Rollback actions tested in simulation mode
- Execution engine tracks rollback dependencies
- Automatic rollback on step failure (configurable)
- Manual rollback via CLI for post-incident recovery

### 2.6 LLM as Co-Pilot

**Principle:** LLMs assist analysts but never make security decisions.

**Rationale:** Current LLMs lack reliability for critical security operations. Use them for cognitive assistance, not autonomous action.

**Implementation:**
- LLM generates investigation summaries from enrichment data
- Suggests next steps based on playbook context
- Translates technical findings for executive reporting
- Provides natural language search over historical incidents
- Graceful degradation when LLM unavailable (deterministic-only mode)

---

## 3. System Architecture

### 3.1 High-Level Component Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                         RUNBOOKPILOT SYSTEM                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────┐     ┌──────────────────────────────────────┐    │
│  │              │     │     ALERT INGESTION LAYER            │    │
│  │  CLI/TUI     │────▶│  ┌────────┐ ┌────────┐ ┌─────────┐  │    │
│  │  Interface   │     │  │ STDIN  │ │Webhook │ │  File   │  │    │
│  │              │     │  └────────┘ └────────┘ └─────────┘  │    │
│  └──────────────┘     │         │         │         │        │    │
│         │             │         └─────────┴─────────┘        │    │
│         │             │                  │                   │    │
│         ▼             │         ┌────────▼────────┐          │    │
│  ┌──────────────┐     │         │  ECS Normalizer │          │    │
│  │   Approval   │     │         └────────┬────────┘          │    │
│  │    Queue     │     └──────────────────┼───────────────────┘    │
│  │   Manager    │                        │                        │
│  └──────┬───────┘                        │                        │
│         │                       ┌────────▼────────┐               │
│         │                       │  Playbook       │               │
│         │                       │  Matcher        │               │
│         │                       │  (ATT&CK/Tag)   │               │
│         │                       └────────┬────────┘               │
│         │                                │                        │
│         │             ┌──────────────────▼──────────────────┐     │
│         │             │      EXECUTION ENGINE               │     │
│         │             │  ┌──────────────────────────────┐   │     │
│         │             │  │   State Machine Core         │   │     │
│         │             │  └──────────┬───────────────────┘   │     │
│         │             │             │                       │     │
│         └─────────────┼──────┬──────┼──────┬────────┐       │     │
│                       │      │      │      │        │       │     │
│                       │  ┌───▼──┐ ┌─▼───┐ ┌▼────┐ ┌▼────┐  │     │
│                       │  │ L0   │ │ L1  │ │ L2  │ │Sim  │  │     │
│                       │  │ Mode │ │Mode │ │Mode │ │Eng  │  │     │
│                       │  └───┬──┘ └──┬──┘ └──┬──┘ └──┬──┘  │     │
│                       └──────┼───────┼───────┼───────┼─────┘     │
│                              │       │       │       │           │
│                       ┌──────▼───────▼───────▼───────▼─────┐     │
│                       │      ACTION ADAPTER LAYER          │     │
│                       │  ┌──────┐ ┌──────┐ ┌──────┐        │     │
│                       │  │ EDR  │ │ SIEM │ │Ticket│  ...   │     │
│                       │  └──────┘ └──────┘ └──────┘        │     │
│                       └────────────────────────────────────┘     │
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │              CROSS-CUTTING SERVICES                      │    │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐    │    │
│  │  │  Audit   │ │ Metrics  │ │   LLM    │ │  Secret  │    │    │
│  │  │  Logger  │ │Collector │ │Assistant │ │  Manager │    │    │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘    │    │
│  └──────────────────────────────────────────────────────────┘    │
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐    │
│  │                   STORAGE LAYER                          │    │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐    │    │
│  │  │Approval  │ │  Audit   │ │Execution │ │Playbook  │    │    │
│  │  │  Queue   │ │   Log    │ │ History  │ │ Library  │    │    │
│  │  │ (SQLite) │ │(SQLite)  │ │(SQLite)  │ │  (YAML)  │    │    │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘    │    │
│  └──────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Technology Stack

| Layer | Technology | Rationale |
|-------|-----------|-----------|
| Runtime | Bun | Fast TypeScript execution, built-in testing, npm compatibility |
| Language | TypeScript | Type safety for security-critical code, excellent tooling |
| Testing | Vitest | Native Bun support, fast, Jest-compatible API |
| CLI Framework | Commander.js | Battle-tested, composable, supports interactive prompts |
| LLM Gateway | OpenRouter | Model-agnostic, fallback support, usage tracking |
| Storage | SQLite | Zero-config, ACID guarantees, easy backup/migration |
| Event Format | ECS (Elastic Common Schema) | Industry standard, SIEM-agnostic |
| Orchestration | Docker Compose | Simple deployment, network isolation, volume management |
| Schema Validation | Zod | TypeScript-native, runtime validation, excellent errors |

---

## 4. Component Design

### 4.1 CLI Interface

**Responsibilities:**
- Parse command-line arguments and options
- Provide interactive TUI for runbook execution
- Display real-time execution status and logs
- Handle approval prompts with context display
- Manage configuration files and credentials

**Interfaces:**

```typescript
interface CLICommands {
  // Execute a playbook
  execute(playbookId: string, alertData: AlertEvent, options: ExecuteOptions): Promise<ExecutionResult>

  // List available playbooks
  list(filters?: PlaybookFilters): Promise<Playbook[]>

  // Validate playbook YAML
  validate(playbookPath: string): Promise<ValidationResult>

  // Review pending approvals
  approve(approvalId: string, decision: ApprovalDecision): Promise<void>

  // View execution history
  history(filters?: HistoryFilters): Promise<ExecutionRecord[]>

  // Rollback a completed execution
  rollback(executionId: string): Promise<RollbackResult>

  // Simulate L2 execution
  simulate(playbookId: string, alertData: AlertEvent): Promise<SimulationResult>
}

interface ExecuteOptions {
  automationLevel: 'L0' | 'L1' | 'L2'
  dryRun?: boolean
  interactive?: boolean
  timeout?: number
}
```

**Dependencies:**
- Execution Engine
- Approval Queue Manager
- Playbook Validator
- Audit Logger

**Implementation Notes:**
- Use Commander.js for command routing
- Ink (React for CLI) for interactive TUI components
- Chalk for colored output and status indicators
- Ora for progress spinners during execution
- Inquirer for approval prompts with rich context

### 4.2 Schema Validator & YAML Parser

**Responsibilities:**
- Parse playbook YAML files
- Validate schema compliance (structure, types, required fields)
- Validate business rules (rollback for write actions, approval gates)
- Resolve template variables in playbook definitions
- Provide detailed error messages with line numbers

**Interfaces:**

```typescript
interface PlaybookValidator {
  // Parse and validate YAML
  parse(yamlContent: string): Promise<ParsedPlaybook>

  // Validate playbook schema
  validate(playbook: ParsedPlaybook): ValidationResult

  // Validate business rules
  validateBusinessRules(playbook: ParsedPlaybook): ValidationResult

  // Resolve template variables
  resolveTemplates(playbook: ParsedPlaybook, context: AlertContext): ResolvedPlaybook
}

interface ValidationResult {
  valid: boolean
  errors: ValidationError[]
  warnings: ValidationWarning[]
}

interface ValidationError {
  path: string          // e.g., "steps[2].rollback"
  line?: number
  message: string
  rule: string          // e.g., "ROLLBACK_REQUIRED"
}
```

**Dependencies:**
- Zod for runtime schema validation
- js-yaml for YAML parsing
- Handlebars for template resolution

**Implementation Notes:**
- Define Zod schemas matching YAML structure
- Custom validators for business rules (rollback, approval)
- Template resolution uses Handlebars syntax: `{{ alert.host_id }}`
- Validate on playbook load and before execution
- Cache validated playbooks with checksum-based invalidation

### 4.3 Execution Engine (State Machine)

**Responsibilities:**
- Orchestrate runbook execution through state transitions
- Manage step sequencing, branching, and error handling
- Enforce automation level restrictions (L0/L1/L2)
- Coordinate with approval gates and adapters
- Track execution state in database
- Handle timeouts and cancellation

**State Machine Design:**

```
                    ┌─────────────┐
                    │   PENDING   │
                    └──────┬──────┘
                           │
                           ▼
                    ┌─────────────┐
              ┌────▶│  RUNNING    │────┐
              │     └──────┬──────┘    │
              │            │           │
              │            ▼           │
              │     ┌─────────────┐    │
              │     │ STEP_EXEC   │    │
              │     └──┬───┬───┬──┘    │
              │        │   │   │       │
              │   ┌────┘   │   └────┐  │
              │   ▼        ▼        ▼  │
              │ WAIT_   STEP_   STEP_  │
              │ APPROVAL SUCCESS FAILED │
              │   │        │        │  │
              │   │        │        ▼  │
              │   │        │    ┌──────────┐
              │   │        │    │ ROLLBACK │
              │   │        │    └──────┬───┘
              │   └────┬───┴────────┬──┘
              │        │            │
              │        ▼            ▼
              │   ┌─────────┐  ┌─────────┐
              └───│ NEXT    │  │ ERROR   │
                  │ STEP    │  │ HALTED  │
                  └────┬────┘  └────┬────┘
                       │            │
                       ▼            ▼
                  ┌──────────────────────┐
                  │   COMPLETED/FAILED   │
                  └──────────────────────┘
```

**Interfaces:**

```typescript
interface ExecutionEngine {
  // Start runbook execution
  execute(playbook: ResolvedPlaybook, context: ExecutionContext): Promise<ExecutionResult>

  // Resume from approval
  resumeFromApproval(executionId: string, approved: boolean): Promise<void>

  // Cancel running execution
  cancel(executionId: string): Promise<void>

  // Get execution status
  getStatus(executionId: string): Promise<ExecutionStatus>
}

interface ExecutionContext {
  executionId: string
  alertEvent: AlertEvent
  automationLevel: 'L0' | 'L1' | 'L2'
  dryRun: boolean
  initiatedBy: string
  initiatedAt: Date
}

interface ExecutionResult {
  executionId: string
  status: 'COMPLETED' | 'FAILED' | 'CANCELLED' | 'AWAITING_APPROVAL'
  steps: StepResult[]
  duration: number
  errorMessage?: string
}

interface StepResult {
  stepId: string
  status: 'SUCCESS' | 'FAILED' | 'SKIPPED' | 'PENDING_APPROVAL'
  startTime: Date
  endTime?: Date
  output?: any
  errorMessage?: string
  approvalId?: string
}
```

**Dependencies:**
- Approval Gate Manager
- Action Adapters
- Simulation Engine
- Audit Logger
- Metrics Collector

**Implementation Notes:**
- XState library for state machine implementation
- Persistent state in SQLite for crash recovery
- Separate execution contexts per runbook instance
- Timeout enforcement at step and playbook level
- Parallel step execution where dependencies allow
- Event-driven architecture for approval notifications

### 4.4 Approval Gate Manager

**Responsibilities:**
- Queue approval requests with full context
- Enforce role-based approval permissions
- Track approval decisions and justifications
- Send notifications for pending approvals
- Auto-escalate time-sensitive approvals
- Maintain approval audit trail

**Interfaces:**

```typescript
interface ApprovalGateManager {
  // Request approval for a step
  requestApproval(request: ApprovalRequest): Promise<string> // returns approvalId

  // Submit approval decision
  submitDecision(approvalId: string, decision: ApprovalDecision): Promise<void>

  // List pending approvals
  listPending(filters?: ApprovalFilters): Promise<ApprovalRequest[]>

  // Get approval details
  getApproval(approvalId: string): Promise<ApprovalRequest>

  // Cancel pending approval
  cancel(approvalId: string): Promise<void>
}

interface ApprovalRequest {
  approvalId: string
  executionId: string
  stepId: string
  stepName: string
  action: string
  parameters: Record<string, any>
  context: {
    alertEvent: AlertEvent
    previousSteps: StepResult[]
    llmSummary?: string
  }
  requiredRole: 'analyst' | 'lead' | 'manager'
  requestedAt: Date
  expiresAt?: Date
  status: 'PENDING' | 'APPROVED' | 'REJECTED' | 'EXPIRED' | 'CANCELLED'
}

interface ApprovalDecision {
  approved: boolean
  justification?: string
  approvedBy: string
  approvedAt: Date
  modifiedParameters?: Record<string, any>
}
```

**Dependencies:**
- Audit Logger
- Notification System (future)
- LLM Assistant (for context summarization)

**Implementation Notes:**
- SQLite table with indexed status and expiry columns
- WebSocket or polling for real-time approval status
- CLI TUI displays approval context in formatted panels
- Approval decisions trigger execution engine resume
- Expired approvals auto-transition to CANCELLED state
- Approval history linked to execution audit trail

### 4.5 Action Adapters

**Responsibilities:**
- Abstract vendor-specific API calls
- Normalize inputs and outputs
- Handle authentication and rate limiting
- Implement retry logic with exponential backoff
- Support both production and simulation modes
- Provide adapter discovery and registration

**Adapter Interface:**

```typescript
interface ActionAdapter {
  // Metadata
  name: string
  version: string
  supportedActions: string[]

  // Lifecycle
  initialize(config: AdapterConfig): Promise<void>
  healthCheck(): Promise<HealthStatus>
  shutdown(): Promise<void>

  // Execution
  execute(action: ActionRequest): Promise<ActionResult>
  simulate(action: ActionRequest): Promise<SimulationResult>
  rollback(executionId: string): Promise<RollbackResult>

  // Validation
  validateParameters(action: string, parameters: any): ValidationResult
}

interface ActionRequest {
  action: string              // e.g., "isolate_host"
  parameters: Record<string, any>
  executionId: string
  stepId: string
  mode: 'production' | 'simulation'
  timeout?: number
}

interface ActionResult {
  success: boolean
  output: any
  duration: number
  errorMessage?: string
  rollbackData?: any        // Data needed for rollback
}

interface SimulationResult {
  wouldSucceed: boolean
  predictedOutput: any
  confidence?: number
  validationErrors?: string[]
  rollbackPlan: string
}
```

**Built-in Adapters (v1):**

| Adapter | Actions | Priority |
|---------|---------|----------|
| Sentinel API | isolate_host, query_logs, create_incident | High |
| CrowdStrike API | isolate_host, quarantine_file, get_device_info | High |
| Splunk API | run_search, get_events | Medium |
| VirusTotal API | check_hash, check_ip, check_domain | Medium |
| ServiceNow API | create_ticket, update_ticket | Medium |
| Generic HTTP | http_get, http_post | High |
| Local Script | execute_script | High |

**Implementation Notes:**
- Adapter registry pattern with plugin discovery
- Each adapter in separate module with dependency injection
- Adapters return standardized result objects
- Simulation mode returns mock data without external calls
- Rate limiting using bottleneck library
- Credential management via Secret Manager component
- Adapter health checks run on initialization and periodically

### 4.6 LLM Assistant (OpenRouter)

**Responsibilities:**
- Generate human-readable summaries of enrichment data
- Suggest next investigation steps based on playbook progress
- Translate technical findings for executive reporting
- Answer analyst questions about alert context
- Provide natural language search over historical incidents
- Gracefully degrade when unavailable

**Interfaces:**

```typescript
interface LLMAssistant {
  // Summarize step outputs
  summarizeEnrichment(stepOutputs: StepResult[]): Promise<string>

  // Suggest next steps
  suggestActions(context: InvestigationContext): Promise<string[]>

  // Generate executive summary
  generateExecutiveSummary(execution: ExecutionResult): Promise<string>

  // Answer analyst questions
  answerQuestion(question: string, context: AlertContext): Promise<string>

  // Search historical incidents
  searchIncidents(query: string): Promise<IncidentMatch[]>

  // Health check
  isAvailable(): Promise<boolean>
}

interface InvestigationContext {
  alertEvent: AlertEvent
  completedSteps: StepResult[]
  remainingSteps: PlaybookStep[]
  automationLevel: 'L0' | 'L1' | 'L2'
}
```

**Dependencies:**
- OpenRouter API client
- Secret Manager (for API keys)
- Metrics Collector (for usage tracking)

**Implementation Notes:**
- OpenRouter as abstraction layer over multiple LLM providers
- Primary model: GPT-4 Turbo or Claude 3.5 Sonnet
- Fallback models: GPT-3.5, Llama 3.1 70B
- Context window management with truncation strategy
- Response streaming for TUI updates
- Graceful degradation: return empty summaries if LLM fails
- No LLM calls in critical execution path
- Cache LLM responses for identical contexts
- Token usage tracking for cost monitoring

### 4.7 Audit Logger

**Responsibilities:**
- Log all execution events with full context
- Maintain immutable audit trail
- Support structured querying of audit data
- Enable compliance reporting
- Provide forensic reconstruction of executions

**Interfaces:**

```typescript
interface AuditLogger {
  // Log execution events
  logExecutionStart(execution: ExecutionContext): Promise<void>
  logExecutionEnd(execution: ExecutionResult): Promise<void>
  logStepStart(executionId: string, step: PlaybookStep): Promise<void>
  logStepEnd(executionId: string, stepResult: StepResult): Promise<void>

  // Log approval events
  logApprovalRequest(approval: ApprovalRequest): Promise<void>
  logApprovalDecision(decision: ApprovalDecision): Promise<void>

  // Log adapter events
  logAdapterCall(executionId: string, adapter: string, action: string, parameters: any): Promise<void>
  logAdapterResult(executionId: string, result: ActionResult): Promise<void>

  // Query audit log
  query(filters: AuditFilters): Promise<AuditEvent[]>

  // Export audit log
  export(format: 'json' | 'csv' | 'syslog', filters?: AuditFilters): Promise<string>
}

interface AuditEvent {
  eventId: string
  timestamp: Date
  eventType: 'EXECUTION_START' | 'STEP_START' | 'APPROVAL_REQUEST' | 'ADAPTER_CALL' | ...
  executionId?: string
  stepId?: string
  approvalId?: string
  actor: string
  details: Record<string, any>
  hash: string              // For immutability verification
}
```

**Dependencies:**
- SQLite for storage
- Crypto module for event hashing

**Implementation Notes:**
- Append-only audit log with SHA-256 chain hashing
- Each event hashes previous event for tamper detection
- Separate audit database from operational database
- Indexed on executionId, timestamp, eventType
- Retention policy configurable (default 90 days)
- Export to SIEM via syslog format
- Structured JSON logging for machine parsing

### 4.8 Metrics Collector

**Responsibilities:**
- Collect execution metrics (duration, success rate, step performance)
- Track approval patterns (approval rate, time-to-approval)
- Monitor adapter health (latency, error rate)
- Aggregate L2 simulation accuracy
- Enable performance optimization and capacity planning

**Interfaces:**

```typescript
interface MetricsCollector {
  // Record execution metrics
  recordExecution(execution: ExecutionResult): Promise<void>
  recordStepDuration(stepId: string, duration: number): Promise<void>

  // Record approval metrics
  recordApproval(approval: ApprovalRequest, decision: ApprovalDecision): Promise<void>

  // Record adapter metrics
  recordAdapterCall(adapter: string, action: string, duration: number, success: boolean): Promise<void>

  // Query metrics
  getExecutionMetrics(timeRange: TimeRange): Promise<ExecutionMetrics>
  getApprovalMetrics(timeRange: TimeRange): Promise<ApprovalMetrics>
  getAdapterMetrics(adapter: string, timeRange: TimeRange): Promise<AdapterMetrics>
}

interface ExecutionMetrics {
  totalExecutions: number
  successRate: number
  avgDuration: number
  p95Duration: number
  byAutomationLevel: Record<'L0' | 'L1' | 'L2', number>
  byPlaybook: Record<string, number>
}

interface ApprovalMetrics {
  totalRequests: number
  approvalRate: number
  avgTimeToApproval: number
  byRole: Record<string, number>
  byAction: Record<string, number>
}
```

**Dependencies:**
- SQLite for time-series storage
- Audit Logger for event data

**Implementation Notes:**
- Time-series tables with downsampling for long-term storage
- Metrics aggregated at 1m, 5m, 1h, 1d intervals
- Prometheus-compatible export endpoint (future)
- CLI commands for metrics dashboard
- Alerts on anomalous patterns (future)

### 4.9 Alert Ingestion

**Responsibilities:**
- Accept alerts from multiple sources (STDIN, webhook, file)
- Normalize to ECS format
- Extract ATT&CK technique IDs
- Match alerts to applicable playbooks
- Queue alerts for execution

**Interfaces:**

```typescript
interface AlertIngestion {
  // Ingest from various sources
  ingestStdin(rawAlert: string): Promise<NormalizedAlert>
  ingestWebhook(request: WebhookRequest): Promise<NormalizedAlert>
  ingestFile(filePath: string): Promise<NormalizedAlert>

  // Normalize to ECS
  normalizeToECS(rawAlert: any, sourceFormat: string): Promise<ECSAlert>

  // Extract metadata
  extractATTCKTechniques(alert: ECSAlert): string[]
  extractPlatform(alert: ECSAlert): string

  // Match playbooks
  matchPlaybooks(alert: NormalizedAlert): Promise<Playbook[]>
}

interface NormalizedAlert {
  ecs: ECSAlert
  attackTechniques: string[]
  platform: string
  detectionSource: 'sigma' | 'yara' | 'suricata' | 'edr' | 'siem' | 'manual'
  detectionRuleId?: string
  matchedPlaybooks: Playbook[]
}

interface ECSAlert {
  '@timestamp': string
  event: {
    kind: string
    category: string[]
    type: string[]
    action: string
  }
  host: {
    id?: string
    name?: string
    ip?: string[]
    os?: object
  }
  process?: object
  file?: object
  network?: object
  threat?: {
    framework: string
    technique: {
      id: string[]
      name: string[]
    }
  }
  // ... full ECS schema support
}
```

**Dependencies:**
- Schema Validator
- Playbook Matcher

**Implementation Notes:**
- ECS schema validation using Zod
- Support for Sigma x-detectforge metadata extraction
- ATT&CK ID extraction from multiple fields (ECS threat.technique.id, Sigma tags)
- Webhook server using Fastify (lightweight, fast)
- File watcher for directory-based ingestion
- STDIN ingestion for pipeline integration
- Playbook matching by: ATT&CK technique, platform, tags, detection source

### 4.10 Simulation Engine

**Responsibilities:**
- Execute L2 playbooks in dry-run mode
- Generate realistic simulation results
- Log intended actions without side effects
- Calculate confidence scores for predictions
- Store simulations in approval queue

**Interfaces:**

```typescript
interface SimulationEngine {
  // Simulate playbook execution
  simulate(playbook: ResolvedPlaybook, context: ExecutionContext): Promise<SimulationReport>

  // Validate simulation plan
  validatePlan(plan: SimulationPlan): Promise<ValidationResult>

  // Compare simulation to actual execution
  comparePrediction(simulationId: string, executionId: string): Promise<AccuracyReport>
}

interface SimulationReport {
  simulationId: string
  playbookId: string
  timestamp: Date
  steps: SimulatedStep[]
  predictedOutcome: 'SUCCESS' | 'PARTIAL' | 'FAILURE'
  confidence: number
  rollbackPlan: RollbackPlan
  estimatedDuration: number
  risksIdentified: string[]
}

interface SimulatedStep {
  stepId: string
  action: string
  parameters: Record<string, any>
  predictedResult: any
  confidence: number
  sideEffects: string[]
  rollbackAction: string
  validationsPassed: boolean
}

interface AccuracyReport {
  simulationId: string
  executionId: string
  accuracy: number
  correctPredictions: number
  incorrectPredictions: number
  stepDifferences: StepDifference[]
}
```

**Dependencies:**
- Action Adapters (for simulation mode)
- Execution Engine
- Approval Queue Manager

**Implementation Notes:**
- Simulation mode flag passed to all adapters
- Adapters return mock results based on validation
- Confidence scores based on parameter validation and historical data
- Simulation results stored in SQLite with links to approval queue
- CLI displays simulation report in rich format
- One-click approval converts simulation to production execution
- Metrics track simulation accuracy over time

---

## 5. Data Flow

### 5.1 L0 Manual Mode Flow

```
1. Alert Ingestion
   ├─ Analyst provides alert via STDIN/file/webhook
   ├─ Alert normalized to ECS format
   ├─ ATT&CK techniques extracted
   └─ Matching playbooks identified

2. Playbook Selection
   ├─ Analyst selects playbook from matches
   ├─ Playbook YAML loaded and validated
   └─ Execution context created (L0 mode)

3. Interactive Execution
   ├─ State machine initializes in L0 mode
   ├─ For each step:
   │   ├─ Display step description in TUI
   │   ├─ Show suggested commands/queries
   │   ├─ Analyst executes manually (outside RunbookPilot)
   │   ├─ Analyst marks step complete/skip/fail
   │   └─ Analyst provides notes/observations
   ├─ LLM Assistant generates step summaries (optional)
   └─ Execution proceeds to next step

4. Completion
   ├─ Final status: COMPLETED (manual)
   ├─ Audit log records all steps and analyst notes
   ├─ LLM generates executive summary
   └─ Metrics updated (manual execution time)
```

**Key Characteristics:**
- Zero automation, pure checklist mode
- Analyst performs all actions manually
- RunbookPilot tracks progress and collects notes
- No adapter calls, no approval gates
- Useful for training and untrusted environments

### 5.2 L1 Semi-Auto Mode Flow

```
1. Alert Ingestion
   [Same as L0]

2. Playbook Selection
   [Same as L0, but L1 mode]

3. Automated Execution
   ├─ State machine initializes in L1 mode
   ├─ For each step:
   │   ├─ Classify step: read-only or write
   │   ├─ If read-only (query, enrichment):
   │   │   ├─ Execute via adapter automatically
   │   │   ├─ Display results in TUI
   │   │   └─ LLM summarizes output
   │   ├─ If write (isolate, block, delete):
   │   │   ├─ Create approval request
   │   │   ├─ Display context + LLM summary
   │   │   ├─ Wait for approval decision
   │   │   ├─ If approved: execute via adapter
   │   │   ├─ If rejected: skip step
   │   │   └─ Store rollback data
   │   └─ Handle errors per on_error policy
   ├─ Execution proceeds automatically or waits
   └─ Approval notifications sent (future)

4. Completion
   ├─ Final status: COMPLETED/FAILED/PARTIAL
   ├─ Audit log records all steps and approvals
   ├─ Metrics updated (automation time, approval time)
   └─ Rollback plan stored for manual recovery
```

**Key Characteristics:**
- Read-only actions automated (queries, enrichment)
- Write actions require explicit approval
- Approval gates enforce human oversight
- Adapter health checks before execution
- Automatic rollback on step failure (configurable)

### 5.3 L2 Simulation Mode Flow

```
1. Alert Ingestion
   [Same as L0]

2. Playbook Selection
   [Same as L0, but L2 mode + simulation flag]

3. Simulation Execution
   ├─ State machine initializes in L2 simulation mode
   ├─ For each step:
   │   ├─ Call adapter.simulate() instead of .execute()
   │   ├─ Adapter validates parameters
   │   ├─ Adapter predicts outcome (mock data)
   │   ├─ Adapter identifies side effects
   │   ├─ Adapter validates rollback plan
   │   ├─ Confidence score calculated
   │   └─ Simulated result logged
   ├─ All steps executed in simulation mode (no writes)
   └─ Simulation completes instantly

4. Simulation Report Generation
   ├─ Aggregate all simulated steps
   ├─ Calculate overall confidence
   ├─ Generate complete rollback plan
   ├─ Identify risks and warnings
   └─ Display report in TUI

5. Approval Queue
   ├─ Store simulation report as approval request
   ├─ Analyst reviews predicted actions
   ├─ Analyst approves/rejects entire plan
   ├─ If approved: convert to L1 production execution
   └─ If rejected: log decision and halt

6. Production Execution (if approved)
   ├─ State machine re-initializes in L1 mode
   ├─ Execute each step via adapters (production mode)
   ├─ Compare actual results to predictions
   └─ Update simulation accuracy metrics

7. Completion
   ├─ Final status: COMPLETED/FAILED
   ├─ Audit log records simulation + execution
   ├─ Accuracy report generated
   └─ Metrics updated (simulation accuracy)
```

**Key Characteristics:**
- Full action plan generated without execution
- Safe exploration of response scenarios
- Transparent preview of automation impact
- One-click approval to execute plan
- Accuracy tracking for future auto-execution (v2)

---

## 6. YAML Playbook Schema

### 6.1 Full Schema Definition

```yaml
runbook:
  # METADATA SECTION
  id: string (uuid, required)
  version: string (semver, required)
  metadata:
    name: string (required)
    description: string (optional)
    created: string (ISO8601, required)
    updated: string (ISO8601, required)
    author: string (optional)
    tags: string[] (optional)
    references: string[] (URLs, optional)

  # TRIGGER SECTION
  triggers:
    detection_sources: enum[] (sigma | yara | suricata | edr | siem | manual)
    mitre_techniques: string[] (ATT&CK IDs, e.g., T1021.002)
    platforms: enum[] (windows | linux | macos | network | cloud)
    severity: enum[] (low | medium | high | critical)
    custom_conditions: object (optional, for advanced matching)

  # CONFIGURATION SECTION
  config:
    automation_level: enum (L0 | L1 | L2, required)
    max_execution_time: string (duration, e.g., "600s", required)
    requires_approval: boolean (required)
    approval_roles: enum[] (analyst | lead | manager)
    timeout_action: enum (halt | continue | escalate, default: halt)
    error_budget: number (max failures before halt, default: 0)

  # VARIABLES SECTION (optional)
  variables:
    var_name: string | number | boolean
    # Example:
    # edr_platform: "crowdstrike"
    # isolation_timeout: 300

  # STEPS SECTION
  steps:
    - id: string (e.g., "step-01", required, unique)
      name: string (required)
      description: string (optional)

      # Action definition
      action: string (required, e.g., "isolate_host")
      executor: string (required, adapter name, e.g., "sentinel_api")

      # Parameters (templated)
      parameters:
        key: value (supports {{ template.syntax }})

      # Approval gate
      approval_required: boolean (default: false)
      approval_roles: enum[] (optional, overrides config.approval_roles)
      approval_timeout: string (duration, optional)

      # Rollback definition (required for write actions)
      rollback:
        action: string (required)
        executor: string (optional, defaults to step executor)
        parameters: object (optional)
        timeout: string (duration, optional)
        on_failure: enum (log | escalate, default: log)

      # Error handling
      on_error: enum (halt | continue | skip, default: halt)
      retry:
        max_attempts: number (default: 1)
        backoff: string (duration, e.g., "5s")

      # Dependencies
      depends_on: string[] (step IDs, optional)

      # Conditions (optional)
      when: string (expression, e.g., "{{ alert.severity == 'critical' }}")

      # Output handling
      output:
        store_as: string (variable name for next steps)
        display: boolean (show in TUI, default: true)
```

### 6.2 Schema Validation Rules

**Business Rules:**
1. If `action` is a write operation (not read-only), `rollback` section is REQUIRED
2. If `config.automation_level` is L1 or L2 and step is write, `approval_required` MUST be true
3. All `depends_on` step IDs must exist in the playbook
4. Template variables in `parameters` must be defined in `variables` or available in alert context
5. `executor` must be a registered adapter name
6. `max_execution_time` must be greater than sum of all step timeouts

**Read-Only Actions:**
- query_logs, get_events, run_search
- get_device_info, get_user_info
- check_hash, check_ip, check_domain
- list_*, describe_*, get_*

**Write Actions:**
- isolate_host, block_ip, quarantine_file
- create_ticket, update_ticket
- execute_script, send_email
- delete_*, modify_*, disable_*

### 6.3 Template Syntax

Templates use Handlebars syntax with ECS alert context:

```yaml
parameters:
  host_id: "{{ alert.host.id }}"
  ip_address: "{{ alert.source.ip }}"
  technique: "{{ alert.threat.technique.id[0] }}"
  severity: "{{ alert.event.severity }}"
```

Available context:
- `{{ alert.* }}` - Full ECS alert object
- `{{ var.* }}` - Playbook variables
- `{{ step_output.* }}` - Previous step outputs
- `{{ execution.* }}` - Execution metadata (id, timestamp, initiator)

Helper functions:
- `{{ now }}` - Current timestamp
- `{{ env.VAR_NAME }}` - Environment variable
- `{{ default value fallback }}` - Default value if undefined

---

## 7. State Machine Design

### 7.1 Execution States

| State | Description | Transitions |
|-------|-------------|-------------|
| PENDING | Execution queued, not started | → RUNNING |
| RUNNING | Execution in progress | → STEP_EXEC |
| STEP_EXEC | Executing a step | → WAIT_APPROVAL, STEP_SUCCESS, STEP_FAILED |
| WAIT_APPROVAL | Waiting for approval decision | → STEP_EXEC (approved), NEXT_STEP (rejected) |
| STEP_SUCCESS | Step completed successfully | → NEXT_STEP |
| STEP_FAILED | Step failed | → ROLLBACK (if configured), ERROR_HALTED, NEXT_STEP |
| ROLLBACK | Rolling back failed step | → NEXT_STEP, ERROR_HALTED |
| NEXT_STEP | Transition to next step | → STEP_EXEC, COMPLETED |
| ERROR_HALTED | Execution halted due to error | → FAILED (terminal) |
| COMPLETED | All steps completed successfully | (terminal) |
| FAILED | Execution failed | (terminal) |
| CANCELLED | Execution cancelled by user | (terminal) |

### 7.2 State Transition Logic

```typescript
class ExecutionStateMachine {
  private state: ExecutionState
  private playbook: ResolvedPlaybook
  private context: ExecutionContext
  private currentStepIndex: number

  async transition(event: StateMachineEvent): Promise<void> {
    switch (this.state) {
      case 'PENDING':
        if (event === 'START') {
          this.state = 'RUNNING'
          this.currentStepIndex = 0
          await this.transition('NEXT_STEP')
        }
        break

      case 'RUNNING':
        if (event === 'NEXT_STEP') {
          const step = this.getNextEligibleStep()
          if (!step) {
            this.state = 'COMPLETED'
            await this.onCompleted()
          } else {
            this.state = 'STEP_EXEC'
            await this.executeStep(step)
          }
        }
        break

      case 'STEP_EXEC':
        // Step execution logic
        const step = this.getCurrentStep()
        const requiresApproval = this.shouldRequestApproval(step)

        if (requiresApproval) {
          await this.requestApproval(step)
          this.state = 'WAIT_APPROVAL'
        } else {
          const result = await this.executeAction(step)
          if (result.success) {
            this.state = 'STEP_SUCCESS'
            await this.transition('NEXT_STEP')
          } else {
            this.state = 'STEP_FAILED'
            await this.handleStepFailure(step, result)
          }
        }
        break

      case 'WAIT_APPROVAL':
        if (event === 'APPROVED') {
          this.state = 'STEP_EXEC'
          const result = await this.executeAction(this.getCurrentStep())
          // ... handle result
        } else if (event === 'REJECTED') {
          this.state = 'NEXT_STEP'
          await this.transition('NEXT_STEP')
        }
        break

      // ... other states
    }
  }

  private getNextEligibleStep(): PlaybookStep | null {
    while (this.currentStepIndex < this.playbook.steps.length) {
      const step = this.playbook.steps[this.currentStepIndex]

      // Check dependencies
      if (!this.areDependenciesMet(step)) {
        this.currentStepIndex++
        continue
      }

      // Check condition
      if (step.when && !this.evaluateCondition(step.when)) {
        this.currentStepIndex++
        continue
      }

      return step
    }
    return null
  }
}
```

### 7.3 Persistent State

Execution state persisted to SQLite for crash recovery:

```sql
CREATE TABLE executions (
  execution_id TEXT PRIMARY KEY,
  playbook_id TEXT NOT NULL,
  state TEXT NOT NULL,
  current_step_index INTEGER,
  context JSON NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  completed_at TEXT
);

CREATE TABLE execution_steps (
  step_execution_id TEXT PRIMARY KEY,
  execution_id TEXT NOT NULL,
  step_id TEXT NOT NULL,
  step_index INTEGER NOT NULL,
  state TEXT NOT NULL,
  output JSON,
  error_message TEXT,
  rollback_data JSON,
  started_at TEXT,
  completed_at TEXT,
  FOREIGN KEY (execution_id) REFERENCES executions(execution_id)
);
```

On startup, RunbookPilot scans for executions in non-terminal states and offers recovery options.

---

## 8. Integration Architecture

### 8.1 DetectForge Integration

**Integration Method:** File-based handoff + ATT&CK technique mapping

**DetectForge Output Format:**
```yaml
# Sigma rule generated by DetectForge
title: LSASS Credential Dumping via Mimikatz
id: a1b2c3d4-e5f6-7890-abcd-ef1234567890
x-detectforge:
  generated_at: 2026-02-10T12:00:00Z
  source_report: "APT29 Tactics 2026"
  confidence: 0.92
  suggested_playbooks:
    - runbook://lsass-credential-dump-response
    - runbook://credential-theft-containment
detection:
  # ... Sigma rule
tags:
  - attack.credential_access
  - attack.t1003.001
  - mitre_attack_t1003_001
```

**Handoff Workflow:**
1. DetectForge generates Sigma rule with x-detectforge metadata
2. Rule deployed to SIEM (e.g., Sentinel, Splunk)
3. SIEM fires alert when rule matches
4. Alert sent to RunbookPilot via webhook/SIEM integration
5. RunbookPilot extracts ATT&CK technique from alert
6. RunbookPilot matches technique to playbook triggers
7. Playbook executed automatically or queued for analyst

**Docker Compose Demo:**
```yaml
version: '3.8'
services:
  detectforge:
    image: detectforge:latest
    volumes:
      - ./reports:/reports
      - ./rules:/output
    environment:
      - OPENROUTER_API_KEY=${OPENROUTER_API_KEY}

  runbookpilot:
    image: runbookpilot:latest
    volumes:
      - ./rules:/alerts
      - ./playbooks:/playbooks
      - ./data:/data
    environment:
      - OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
      - AUTOMATION_LEVEL=L1
    depends_on:
      - detectforge

  demo-siem:
    image: wazuh/wazuh:latest
    # ... config
```

**Standalone Mode:**
- STDIN ingestion: `cat alert.json | runbookpilot execute --auto`
- File watcher: `runbookpilot watch /var/alerts --match-playbooks`
- Webhook: `runbookpilot serve --port 8080`

### 8.2 SIEM Integration

**Supported SIEMs:**
- Microsoft Sentinel (Azure Monitor API)
- Splunk (REST API + Webhook)
- Elastic Security (Elasticsearch API)
- Wazuh (API + File ingestion)

**Integration Pattern:**
```
SIEM Alert → Webhook → RunbookPilot Ingestion → Normalization → Execution
```

**Webhook Payload (Example - Sentinel):**
```json
{
  "alertId": "abc123",
  "alertDisplayName": "Suspicious LSASS Access",
  "severity": "High",
  "tactics": ["CredentialAccess"],
  "techniques": ["T1003.001"],
  "entities": [
    {
      "type": "host",
      "hostName": "WS01.corp.local",
      "ntDomain": "CORP"
    },
    {
      "type": "process",
      "commandLine": "mimikatz.exe sekurlsa::logonpasswords"
    }
  ],
  "extendedProperties": {
    "detectionSource": "sigma",
    "ruleId": "a1b2c3d4-..."
  }
}
```

**Normalization to ECS:**
RunbookPilot provides SIEM-specific normalizers that map vendor formats to ECS.

### 8.3 EDR Integration

**Supported EDRs:**
- CrowdStrike Falcon (API)
- Microsoft Defender for Endpoint (Graph API)
- SentinelOne (API)
- Carbon Black (API)

**Common Actions:**
- `isolate_host(host_id)` - Network isolation
- `quarantine_file(host_id, file_hash)` - Quarantine malware
- `get_device_info(host_id)` - Retrieve device details
- `restore_connectivity(host_id)` - Rollback isolation

**Example Adapter (CrowdStrike):**
```typescript
class CrowdStrikeAdapter implements ActionAdapter {
  async execute(action: ActionRequest): Promise<ActionResult> {
    switch (action.action) {
      case 'isolate_host':
        const deviceId = action.parameters.host_id
        const response = await this.api.post('/devices/entities/devices-actions/v2', {
          action_name: 'contain',
          ids: [deviceId]
        })
        return {
          success: response.meta.query_time > 0,
          output: { isolation_id: response.resources[0] },
          rollbackData: { deviceId, isolation_id: response.resources[0] }
        }
      // ... other actions
    }
  }

  async rollback(executionId: string): Promise<RollbackResult> {
    const rollbackData = await this.getRollbackData(executionId)
    await this.api.post('/devices/entities/devices-actions/v2', {
      action_name: 'lift_containment',
      ids: [rollbackData.deviceId]
    })
    return { success: true }
  }
}
```

### 8.4 Ticketing Integration

**Supported Systems:**
- ServiceNow (REST API)
- Jira (REST API)
- PagerDuty (Events API)

**Common Actions:**
- `create_ticket(title, description, priority)` - Create incident
- `update_ticket(ticket_id, status, notes)` - Update incident
- `assign_ticket(ticket_id, assignee)` - Assign to analyst

**Integration Pattern:**
Playbooks include ticketing steps for audit trail and escalation:

```yaml
steps:
  - id: step-01
    name: "Create incident ticket"
    action: create_ticket
    executor: servicenow_api
    parameters:
      short_description: "{{ alert.event.action }} - {{ alert.host.name }}"
      description: "{{ llm_summary }}"
      priority: "{{ alert.event.severity }}"
      assignment_group: "SOC Team"
    output:
      store_as: ticket_id
```

---

## 9. Storage Design

### 9.1 SQLite Schema

RunbookPilot uses three SQLite databases:

1. **operational.db** - Active execution state
2. **audit.db** - Immutable audit log
3. **metrics.db** - Time-series metrics

**operational.db Schema:**

```sql
-- Executions table
CREATE TABLE executions (
  execution_id TEXT PRIMARY KEY,
  playbook_id TEXT NOT NULL,
  playbook_version TEXT NOT NULL,
  state TEXT NOT NULL,
  automation_level TEXT NOT NULL,
  current_step_index INTEGER,
  alert_data JSON NOT NULL,
  context JSON NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  completed_at TEXT,
  error_message TEXT
);

CREATE INDEX idx_executions_state ON executions(state);
CREATE INDEX idx_executions_created ON executions(created_at);

-- Execution steps table
CREATE TABLE execution_steps (
  step_execution_id TEXT PRIMARY KEY,
  execution_id TEXT NOT NULL,
  step_id TEXT NOT NULL,
  step_index INTEGER NOT NULL,
  state TEXT NOT NULL,
  output JSON,
  error_message TEXT,
  rollback_data JSON,
  started_at TEXT,
  completed_at TEXT,
  duration_ms INTEGER,
  FOREIGN KEY (execution_id) REFERENCES executions(execution_id)
);

CREATE INDEX idx_execution_steps_execution ON execution_steps(execution_id);

-- Approval queue table
CREATE TABLE approval_queue (
  approval_id TEXT PRIMARY KEY,
  execution_id TEXT NOT NULL,
  step_id TEXT NOT NULL,
  step_name TEXT NOT NULL,
  action TEXT NOT NULL,
  parameters JSON NOT NULL,
  context JSON NOT NULL,
  required_role TEXT NOT NULL,
  status TEXT NOT NULL,
  requested_at TEXT NOT NULL,
  expires_at TEXT,
  approved_by TEXT,
  approved_at TEXT,
  decision JSON,
  FOREIGN KEY (execution_id) REFERENCES executions(execution_id)
);

CREATE INDEX idx_approval_queue_status ON approval_queue(status);
CREATE INDEX idx_approval_queue_expires ON approval_queue(expires_at);

-- Simulations table
CREATE TABLE simulations (
  simulation_id TEXT PRIMARY KEY,
  execution_id TEXT,
  playbook_id TEXT NOT NULL,
  alert_data JSON NOT NULL,
  simulation_report JSON NOT NULL,
  created_at TEXT NOT NULL,
  approved BOOLEAN,
  approved_at TEXT
);

CREATE INDEX idx_simulations_playbook ON simulations(playbook_id);
```

**audit.db Schema:**

```sql
-- Audit events table (append-only)
CREATE TABLE audit_events (
  event_id TEXT PRIMARY KEY,
  timestamp TEXT NOT NULL,
  event_type TEXT NOT NULL,
  execution_id TEXT,
  step_id TEXT,
  approval_id TEXT,
  actor TEXT NOT NULL,
  details JSON NOT NULL,
  previous_hash TEXT,
  hash TEXT NOT NULL
);

CREATE INDEX idx_audit_timestamp ON audit_events(timestamp);
CREATE INDEX idx_audit_execution ON audit_events(execution_id);
CREATE INDEX idx_audit_type ON audit_events(event_type);

-- Hash chain verification view
CREATE VIEW hash_chain_verification AS
SELECT
  event_id,
  timestamp,
  hash,
  previous_hash,
  LEAD(hash) OVER (ORDER BY timestamp) as next_expected_hash,
  CASE
    WHEN previous_hash IS NULL THEN 'GENESIS'
    WHEN previous_hash = LAG(hash) OVER (ORDER BY timestamp) THEN 'VALID'
    ELSE 'TAMPERED'
  END as chain_status
FROM audit_events;
```

**metrics.db Schema:**

```sql
-- Execution metrics (time-series)
CREATE TABLE execution_metrics (
  metric_id TEXT PRIMARY KEY,
  timestamp TEXT NOT NULL,
  playbook_id TEXT NOT NULL,
  automation_level TEXT NOT NULL,
  status TEXT NOT NULL,
  duration_ms INTEGER NOT NULL,
  step_count INTEGER NOT NULL
);

CREATE INDEX idx_metrics_timestamp ON execution_metrics(timestamp);
CREATE INDEX idx_metrics_playbook ON execution_metrics(playbook_id);

-- Approval metrics
CREATE TABLE approval_metrics (
  metric_id TEXT PRIMARY KEY,
  timestamp TEXT NOT NULL,
  action TEXT NOT NULL,
  required_role TEXT NOT NULL,
  approved BOOLEAN NOT NULL,
  time_to_decision_ms INTEGER NOT NULL
);

-- Adapter metrics
CREATE TABLE adapter_metrics (
  metric_id TEXT PRIMARY KEY,
  timestamp TEXT NOT NULL,
  adapter_name TEXT NOT NULL,
  action TEXT NOT NULL,
  success BOOLEAN NOT NULL,
  duration_ms INTEGER NOT NULL
);

-- Aggregated metrics (1h rollup)
CREATE TABLE hourly_metrics (
  hour TEXT NOT NULL,
  metric_type TEXT NOT NULL,
  metric_name TEXT NOT NULL,
  value REAL NOT NULL,
  PRIMARY KEY (hour, metric_type, metric_name)
);
```

### 9.2 Data Retention

| Database | Table | Retention | Archival |
|----------|-------|-----------|----------|
| operational.db | executions | 30 days | Export to JSON |
| operational.db | approval_queue | 90 days | Export to JSON |
| operational.db | simulations | 60 days | Export to JSON |
| audit.db | audit_events | 1 year | Export to SIEM |
| metrics.db | raw metrics | 90 days | Roll up to hourly |
| metrics.db | hourly_metrics | 2 years | Export to CSV |

### 9.3 Backup Strategy

- Daily SQLite backups using `.backup` command
- Backups stored in `/data/backups` with rotation
- Audit log backups signed with SHA-256 checksum
- Restore tested monthly via CI/CD

---

## 10. LLM Integration

### 10.1 Where LLMs Help

**Approved Use Cases:**
1. **Enrichment Summarization** - Convert raw API responses to human-readable summaries
2. **Investigation Guidance** - Suggest next steps based on playbook context
3. **Executive Reporting** - Generate non-technical summaries for management
4. **Historical Search** - Natural language queries over past incidents
5. **Playbook Authoring Assistance** - Suggest playbook structures (future)

**Example: Enrichment Summarization**
```typescript
// Input: Raw VirusTotal API response
const vtResponse = {
  data: {
    attributes: {
      last_analysis_stats: { malicious: 47, suspicious: 3, undetected: 15 },
      popular_threat_classification: { suggested_threat_label: "ransomware" }
    }
  }
}

// LLM summarization
const summary = await llm.summarizeEnrichment([{
  stepId: "vt-lookup",
  output: vtResponse
}])

// Output: "VirusTotal analysis shows this file is likely ransomware, with 47/65 vendors detecting it as malicious. High confidence threat."
```

### 10.2 Where LLMs Are Banned

**Prohibited Use Cases:**
1. Decision-making for approval gates (human only)
2. Action parameter generation (must be from playbook/alert)
3. Playbook execution logic (state machine only)
4. Security policy interpretation (deterministic rules only)
5. Credential handling or sensitive data processing

### 10.3 Graceful Degradation

When LLM unavailable (network failure, quota exceeded, timeout):

```typescript
class LLMAssistant {
  async summarizeEnrichment(steps: StepResult[]): Promise<string> {
    try {
      // Attempt LLM call with timeout
      const response = await this.openRouter.chat({
        messages: [/* ... */],
        timeout: 5000
      })
      return response.content
    } catch (error) {
      // Fallback to deterministic summary
      logger.warn('LLM unavailable, using fallback summarization')
      return this.fallbackSummarize(steps)
    }
  }

  private fallbackSummarize(steps: StepResult[]): string {
    // Generate structured summary without LLM
    return steps.map(step =>
      `${step.stepId}: ${step.status} (${step.duration}ms)`
    ).join('\n')
  }
}
```

**Fallback Strategies:**
- Enrichment: Show raw JSON with syntax highlighting
- Suggestions: Show playbook steps without AI commentary
- Reports: Template-based reports with data substitution
- Search: Exact keyword matching on audit logs

### 10.4 OpenRouter Configuration

```typescript
interface OpenRouterConfig {
  apiKey: string
  baseUrl: string
  models: {
    primary: string      // e.g., "anthropic/claude-3.5-sonnet"
    fallback: string[]   // e.g., ["openai/gpt-4-turbo", "meta-llama/llama-3.1-70b"]
  }
  timeout: number        // milliseconds
  maxTokens: number
  temperature: number
  retries: number
}

// Example configuration
const config: OpenRouterConfig = {
  apiKey: process.env.OPENROUTER_API_KEY,
  baseUrl: "https://openrouter.ai/api/v1",
  models: {
    primary: "anthropic/claude-3.5-sonnet",
    fallback: [
      "openai/gpt-4-turbo",
      "google/gemini-pro",
      "meta-llama/llama-3.1-70b-instruct"
    ]
  },
  timeout: 30000,
  maxTokens: 2048,
  temperature: 0.3,
  retries: 2
}
```

### 10.5 Cost Management

- Track token usage per execution in metrics.db
- Set monthly budget limits with alerts
- Prefer smaller models for simple tasks (summaries)
- Cache LLM responses for identical contexts
- Disable LLM features if budget exceeded

---

## 11. Security Architecture

### 11.1 RBAC (Role-Based Access Control)

**Roles:**

| Role | Permissions | Use Cases |
|------|-------------|-----------|
| Analyst | Execute L0/L1 playbooks, approve L1 write actions | Day-to-day SOC operations |
| Lead | All Analyst + approve L2 simulations | Shift lead, escalation point |
| Manager | All Lead + modify playbooks, view all metrics | SOC management, tuning |
| Admin | All Manager + configure adapters, access credentials | Platform administration |

**Implementation:**
```typescript
interface User {
  userId: string
  username: string
  roles: Role[]
  permissions: Permission[]
}

enum Role {
  ANALYST = 'analyst',
  LEAD = 'lead',
  MANAGER = 'manager',
  ADMIN = 'admin'
}

enum Permission {
  EXECUTE_L0 = 'execute:l0',
  EXECUTE_L1 = 'execute:l1',
  EXECUTE_L2 = 'execute:l2',
  APPROVE_L1_WRITE = 'approve:l1:write',
  APPROVE_L2_SIM = 'approve:l2:simulation',
  MODIFY_PLAYBOOKS = 'playbooks:modify',
  CONFIGURE_ADAPTERS = 'adapters:configure',
  VIEW_CREDENTIALS = 'credentials:view'
}

class AuthorizationService {
  canApprove(user: User, approval: ApprovalRequest): boolean {
    const requiredPerm = this.getRequiredPermission(approval)
    return user.permissions.includes(requiredPerm)
  }
}
```

**v1 Implementation:**
- Simple file-based user database (YAML)
- Password authentication via bcrypt
- Session tokens (JWT) for CLI
- Future: Integration with corporate SSO (SAML, OAuth)

### 11.2 Credential Management

**Principles:**
- Never store plaintext credentials
- Encrypt at rest with AES-256
- Rotate credentials regularly
- Audit all credential access

**Secret Storage:**
```typescript
interface SecretManager {
  // Store encrypted credential
  store(name: string, value: string, tags?: string[]): Promise<void>

  // Retrieve and decrypt credential
  retrieve(name: string): Promise<string>

  // List available secrets (names only)
  list(tags?: string[]): Promise<string[]>

  // Delete credential
  delete(name: string): Promise<void>

  // Rotate credential
  rotate(name: string, newValue: string): Promise<void>
}

class FileSecretManager implements SecretManager {
  private encryptionKey: Buffer

  constructor() {
    // Derive encryption key from master password + system salt
    this.encryptionKey = this.deriveKey(
      process.env.RUNBOOKPILOT_MASTER_KEY,
      systemSalt
    )
  }

  async store(name: string, value: string): Promise<void> {
    const encrypted = this.encrypt(value)
    await fs.writeFile(
      `/data/secrets/${name}.enc`,
      JSON.stringify({
        ciphertext: encrypted.ciphertext,
        iv: encrypted.iv,
        createdAt: new Date().toISOString()
      })
    )
  }

  private encrypt(plaintext: string): EncryptedData {
    const iv = crypto.randomBytes(16)
    const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv)
    const ciphertext = Buffer.concat([
      cipher.update(plaintext, 'utf8'),
      cipher.final()
    ])
    return { ciphertext, iv, authTag: cipher.getAuthTag() }
  }
}
```

**Adapter Credential Injection:**
```yaml
# Playbook references credentials by name
steps:
  - id: step-01
    action: isolate_host
    executor: crowdstrike_api
    parameters:
      host_id: "{{ alert.host.id }}"
      # Credential injected at runtime, never in YAML
```

```typescript
// Adapter initialization
class CrowdStrikeAdapter {
  async initialize(config: AdapterConfig): Promise<void> {
    // Retrieve credential from secret manager
    const apiKey = await secretManager.retrieve('crowdstrike_api_key')
    this.client = new CrowdStrikeClient({ apiKey })
  }
}
```

### 11.3 Audit Trail

**Audit Event Types:**
- EXECUTION_START, EXECUTION_END
- STEP_START, STEP_END
- APPROVAL_REQUEST, APPROVAL_DECISION
- ADAPTER_CALL, ADAPTER_RESULT
- CREDENTIAL_ACCESS
- PLAYBOOK_MODIFIED
- CONFIG_CHANGED

**Immutability Guarantee:**
- Append-only audit log
- SHA-256 hash chain (each event hashes previous)
- Genesis event with system initialization hash
- Tampering detection via hash verification

**Example Audit Chain:**
```
Event 1 (Genesis):
  hash: SHA256(systemInfo + timestamp)
  previous_hash: null

Event 2:
  hash: SHA256(event2_data + Event1.hash)
  previous_hash: Event1.hash

Event 3:
  hash: SHA256(event3_data + Event2.hash)
  previous_hash: Event2.hash
```

If Event 2 is modified after Event 3 exists, Event 3's previous_hash will not match Event 2's new hash, detecting tampering.

### 11.4 Input Validation

**YAML Playbook Validation:**
- Schema validation via Zod
- YAML bomb protection (max depth, max keys)
- Template injection prevention (whitelist Handlebars helpers)
- Path traversal prevention in file references

**Alert Validation:**
- ECS schema validation
- Max payload size (10MB)
- Required fields enforcement
- Malicious payload detection (e.g., SQL injection in strings)

**Adapter Parameter Validation:**
- Type checking
- Range validation (e.g., timeout > 0)
- Format validation (e.g., IP addresses, UUIDs)
- Dangerous command detection (e.g., `rm -rf /`)

**Example:**
```typescript
class ParameterValidator {
  validate(action: string, parameters: any): ValidationResult {
    const schema = this.getSchema(action)

    // Type and structure validation
    const result = schema.safeParse(parameters)
    if (!result.success) {
      return { valid: false, errors: result.error.issues }
    }

    // Business rule validation
    if (action === 'execute_script') {
      if (this.containsDangerousCommands(parameters.script)) {
        return {
          valid: false,
          errors: [{ message: 'Dangerous command detected in script' }]
        }
      }
    }

    return { valid: true, errors: [] }
  }

  private containsDangerousCommands(script: string): boolean {
    const dangerous = [
      /rm\s+-rf\s+\//,
      /mkfs\./,
      /dd\s+if=/,
      /:(){ :|:& };:/  // fork bomb
    ]
    return dangerous.some(pattern => pattern.test(script))
  }
}
```

---

## 12. Deployment Architecture

### 12.1 Docker Image

**Dockerfile:**
```dockerfile
FROM oven/bun:1.0-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package.json bun.lockb ./
RUN bun install --frozen-lockfile

# Copy source and build
COPY . .
RUN bun run build

# Production image
FROM oven/bun:1.0-alpine

WORKDIR /app

# Create non-root user
RUN addgroup -S runbookpilot && adduser -S runbookpilot -G runbookpilot

# Copy built artifacts
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

# Create data directories
RUN mkdir -p /data/playbooks /data/db /data/secrets /data/logs && \
    chown -R runbookpilot:runbookpilot /data

USER runbookpilot

VOLUME ["/data"]

EXPOSE 8080

ENTRYPOINT ["bun", "run", "dist/cli.js"]
CMD ["serve", "--port", "8080"]
```

### 12.2 Docker Compose

**docker-compose.yml:**
```yaml
version: '3.8'

services:
  runbookpilot:
    image: runbookpilot:latest
    container_name: runbookpilot
    restart: unless-stopped
    environment:
      - OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
      - RUNBOOKPILOT_MASTER_KEY=${RUNBOOKPILOT_MASTER_KEY}
      - AUTOMATION_LEVEL=L1
      - LOG_LEVEL=info
    volumes:
      - ./playbooks:/data/playbooks:ro
      - ./data/db:/data/db
      - ./data/secrets:/data/secrets
      - ./data/logs:/data/logs
    ports:
      - "8080:8080"
    networks:
      - runbookpilot
    healthcheck:
      test: ["CMD", "bun", "run", "dist/cli.js", "health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Optional: Webhook proxy for SIEM integration
  webhook-proxy:
    image: nginx:alpine
    container_name: webhook-proxy
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "443:443"
    networks:
      - runbookpilot
    depends_on:
      - runbookpilot

networks:
  runbookpilot:
    driver: bridge
```

### 12.3 Standalone Mode

**CLI Installation:**
```bash
# Global installation
npm install -g runbookpilot

# Or via Bun
bun install -g runbookpilot

# Verify installation
runbookpilot --version
```

**Usage:**
```bash
# Interactive mode
runbookpilot execute --interactive

# STDIN mode
cat alert.json | runbookpilot execute --playbook lsass-dump --auto

# File watcher mode
runbookpilot watch /var/siem/alerts --match-playbooks

# Webhook server mode
runbookpilot serve --port 8080

# Approval review
runbookpilot approvals list
runbookpilot approvals approve abc123 --justification "Verified with EDR logs"

# Simulation mode
runbookpilot simulate --playbook ransomware-contain --alert alert.json
```

### 12.4 Configuration

**Configuration File:** `/etc/runbookpilot/config.yaml`
```yaml
runbookpilot:
  # Data directories
  data_dir: /var/lib/runbookpilot
  playbook_dir: /etc/runbookpilot/playbooks

  # Database paths
  databases:
    operational: ${data_dir}/operational.db
    audit: ${data_dir}/audit.db
    metrics: ${data_dir}/metrics.db

  # Secret management
  secrets:
    backend: file  # file | vault | aws_secrets_manager
    encryption_key_env: RUNBOOKPILOT_MASTER_KEY

  # LLM configuration
  llm:
    provider: openrouter
    api_key_env: OPENROUTER_API_KEY
    primary_model: anthropic/claude-3.5-sonnet
    fallback_models:
      - openai/gpt-4-turbo
      - meta-llama/llama-3.1-70b-instruct
    timeout_ms: 30000
    max_tokens: 2048
    enable_fallback: true

  # Execution defaults
  execution:
    default_automation_level: L1
    max_concurrent_executions: 10
    step_timeout_ms: 300000
    enable_rollback_on_failure: true

  # Webhook server
  webhook:
    enabled: true
    port: 8080
    auth_type: bearer_token  # none | bearer_token | hmac
    auth_secret_env: WEBHOOK_SECRET

  # Logging
  logging:
    level: info
    format: json
    output: /var/log/runbookpilot/app.log
    rotation: daily

  # Metrics
  metrics:
    enabled: true
    retention_days: 90
    prometheus_export: false
```

---

## 13. Error Handling

### 13.1 Failure Modes

| Failure Mode | Detection | Recovery Strategy |
|--------------|-----------|-------------------|
| Step timeout | Timer expiry | Retry or rollback based on config |
| Adapter failure | HTTP error, exception | Retry with backoff, then halt |
| Approval timeout | Expiry time reached | Auto-reject, escalate, or halt |
| Invalid playbook | Schema validation | Reject execution, log error |
| LLM unavailable | Timeout, 5xx error | Graceful degradation to deterministic |
| Database corruption | SQLite error | Restore from backup, alert admin |
| Credential unavailable | Secret retrieval failure | Halt execution, alert admin |
| Rollback failure | Exception during rollback | Log critical error, manual intervention |

### 13.2 Error Handling Policies

**Step-Level Error Handling:**
```yaml
steps:
  - id: step-01
    action: query_logs
    on_error: continue    # Options: halt | continue | skip
    retry:
      max_attempts: 3
      backoff: exponential  # linear | exponential
      backoff_base_ms: 1000
```

**Execution-Level Error Budget:**
```yaml
config:
  error_budget: 2  # Allow up to 2 step failures before halting
```

**Automatic Rollback:**
```yaml
config:
  enable_auto_rollback: true  # Rollback on any step failure
```

### 13.3 Error Recovery Workflow

```typescript
class ErrorHandler {
  async handleStepFailure(
    execution: Execution,
    step: PlaybookStep,
    error: Error
  ): Promise<RecoveryAction> {

    // Log error
    await auditLogger.logStepError(execution.id, step.id, error)

    // Check if retriable
    if (this.isRetriable(error) && step.retry) {
      const attempt = this.getAttemptCount(execution.id, step.id)
      if (attempt < step.retry.max_attempts) {
        await this.wait(this.calculateBackoff(step.retry, attempt))
        return RecoveryAction.RETRY
      }
    }

    // Check on_error policy
    switch (step.on_error) {
      case 'continue':
        return RecoveryAction.CONTINUE_NEXT_STEP

      case 'skip':
        return RecoveryAction.SKIP_STEP

      case 'halt':
      default:
        // Check if rollback defined
        if (step.rollback) {
          await this.executeRollback(execution, step)
          return RecoveryAction.HALT_AFTER_ROLLBACK
        }
        return RecoveryAction.HALT
    }
  }

  private isRetriable(error: Error): boolean {
    // Network errors, timeouts, 5xx errors are retriable
    // 4xx client errors, validation errors are not
    if (error instanceof NetworkError) return true
    if (error instanceof TimeoutError) return true
    if (error instanceof HTTPError && error.status >= 500) return true
    return false
  }

  private calculateBackoff(config: RetryConfig, attempt: number): number {
    if (config.backoff === 'exponential') {
      return config.backoff_base_ms * Math.pow(2, attempt)
    }
    return config.backoff_base_ms
  }
}
```

### 13.4 Crash Recovery

On startup, RunbookPilot scans for incomplete executions:

```typescript
class StartupRecovery {
  async recoverIncompleteExecutions(): Promise<void> {
    const incomplete = await db.query(
      `SELECT * FROM executions WHERE state NOT IN ('COMPLETED', 'FAILED', 'CANCELLED')`
    )

    for (const execution of incomplete) {
      console.log(`Found incomplete execution: ${execution.execution_id}`)

      // Offer recovery options
      const action = await prompt.select({
        message: `Recover execution ${execution.execution_id}?`,
        choices: [
          { name: 'Resume', value: 'resume' },
          { name: 'Rollback', value: 'rollback' },
          { name: 'Mark failed', value: 'fail' },
          { name: 'Skip', value: 'skip' }
        ]
      })

      switch (action) {
        case 'resume':
          await executionEngine.resume(execution.execution_id)
          break
        case 'rollback':
          await executionEngine.rollback(execution.execution_id)
          break
        case 'fail':
          await db.update('executions', {
            execution_id: execution.execution_id,
            state: 'FAILED',
            error_message: 'Marked failed during crash recovery'
          })
          break
      }
    }
  }
}
```

---

## 14. Future Architecture (v2+)

### 14.1 Living Runbooks

**Concept:** Playbooks that learn from analyst decisions and adapt over time.

**Implementation:**
- Track approval patterns (which actions get approved vs rejected)
- Adjust automation levels dynamically (promote L1 to L2 for high-approval steps)
- Suggest playbook optimizations based on execution metrics
- A/B test playbook variations

**Example:**
```typescript
class LivingRunbookEngine {
  async analyzePlaybookPerformance(playbookId: string): Promise<OptimizationSuggestions> {
    const executions = await this.getExecutionHistory(playbookId, { days: 90 })

    // Identify frequently skipped steps
    const skippedSteps = this.identifySkippedSteps(executions)

    // Identify high-approval-rate steps
    const autoApprovable = this.identifyAutoApprovable(executions, { threshold: 0.95 })

    // Identify slow steps
    const slowSteps = this.identifySlow Steps(executions, { p95Threshold: 60000 })

    return {
      suggestions: [
        ...skippedSteps.map(s => ({
          type: 'REMOVE_STEP',
          stepId: s.stepId,
          reason: `Skipped in ${s.skipRate}% of executions`
        })),
        ...autoApprovable.map(s => ({
          type: 'PROMOTE_TO_L2',
          stepId: s.stepId,
          reason: `Approved in ${s.approvalRate}% of executions`
        })),
        ...slowSteps.map(s => ({
          type: 'OPTIMIZE_STEP',
          stepId: s.stepId,
          reason: `P95 duration: ${s.p95Duration}ms`
        }))
      ]
    }
  }
}
```

### 14.2 Auto-L2 Execution

**Concept:** Automatically execute L2 actions when confidence exceeds threshold.

**Requirements:**
- Minimum N successful simulations vs actual executions
- Approval rate > 98% for specific action
- No rollbacks triggered in last M executions
- Explicit opt-in per playbook

**Implementation:**
```yaml
runbook:
  config:
    automation_level: L2
    auto_execute:
      enabled: true
      confidence_threshold: 0.95
      min_historical_executions: 100
      min_approval_rate: 0.98
      excluded_actions:
        - delete_*
        - disable_user
```

```typescript
class AutoL2Engine {
  async shouldAutoExecute(step: PlaybookStep, history: StepHistory): Promise<boolean> {
    // Check opt-in
    if (!playbook.config.auto_execute?.enabled) return false

    // Check excluded actions
    if (this.isExcluded(step.action, playbook.config.auto_execute.excluded_actions)) {
      return false
    }

    // Calculate confidence
    const confidence = this.calculateConfidence(step, history)
    if (confidence < playbook.config.auto_execute.confidence_threshold) {
      return false
    }

    // Check historical data
    const stats = await this.getStepStats(step.id)
    if (stats.totalExecutions < playbook.config.auto_execute.min_historical_executions) {
      return false
    }
    if (stats.approvalRate < playbook.config.auto_execute.min_approval_rate) {
      return false
    }

    // All checks passed
    return true
  }
}
```

### 14.3 Hybrid Execution Engine

**Concept:** Combine deterministic rules with ML-based decision support.

**Use Cases:**
- Anomaly detection for step output validation
- Predicted impact assessment for L2 actions
- Contextual priority scoring for approval queue
- Auto-classification of alert severity

**Architecture:**
```
┌──────────────────────────────────────┐
│     HYBRID EXECUTION ENGINE          │
├──────────────────────────────────────┤
│                                      │
│  ┌────────────────────────────────┐  │
│  │  Deterministic Core            │  │
│  │  (State Machine, Always Active)│  │
│  └──────────────┬─────────────────┘  │
│                 │                    │
│                 ▼                    │
│  ┌────────────────────────────────┐  │
│  │  ML Advisory Layer             │  │
│  │  (Optional, Non-Blocking)      │  │
│  │  ┌──────┐ ┌──────┐ ┌──────┐   │  │
│  │  │Anomaly│ │Impact│ │Priority│  │  │
│  │  │Detect │ │Predict│ │Score  │  │  │
│  │  └──────┘ └──────┘ └──────┘   │  │
│  └──────────────┬─────────────────┘  │
│                 │                    │
│                 ▼                    │
│  ┌────────────────────────────────┐  │
│  │  Decision Fusion               │  │
│  │  (Deterministic + ML Advice)   │  │
│  └────────────────────────────────┘  │
└──────────────────────────────────────┘
```

**Key Principle:** ML predictions never override deterministic logic. They provide context for human decisions.

### 14.4 ML Confidence Scoring

**Training Data:**
- Historical executions with outcomes
- Analyst approval decisions and justifications
- Step output patterns for successful vs failed executions
- Alert characteristics correlated with playbook success

**Model Architecture:**
- Lightweight gradient boosting (XGBoost, LightGBM)
- Input features: Alert ECS fields, playbook metadata, historical stats
- Output: Confidence score (0-1) for predicted success

**Integration:**
```typescript
class MLConfidenceEngine {
  private model: XGBoostModel

  async predictExecutionSuccess(
    playbook: Playbook,
    alert: ECSAlert,
    context: ExecutionContext
  ): Promise<ConfidencePrediction> {

    const features = this.extractFeatures(playbook, alert, context)
    const prediction = await this.model.predict(features)

    return {
      confidence: prediction.score,
      factors: prediction.featureImportance,
      explanation: this.generateExplanation(prediction)
    }
  }

  private extractFeatures(
    playbook: Playbook,
    alert: ECSAlert,
    context: ExecutionContext
  ): FeatureVector {
    return {
      // Alert features
      alert_severity: alert.event.severity,
      technique_count: alert.threat?.technique?.id?.length ?? 0,

      // Playbook features
      step_count: playbook.steps.length,
      automation_level: context.automationLevel,

      // Historical features
      playbook_success_rate: this.getHistoricalSuccessRate(playbook.id),
      avg_approval_rate: this.getAvgApprovalRate(playbook.id),

      // Time features
      hour_of_day: new Date().getHours(),
      day_of_week: new Date().getDay()
    }
  }
}
```

### 14.5 Advanced Simulation

**Concept:** Multi-branch simulation with outcome forecasting.

**Features:**
- Simulate multiple playbook variants simultaneously
- Predict downstream impacts (e.g., "Isolating this host will affect 3 services")
- Risk scoring for each simulation branch
- Recommendation engine for optimal response path

**Example:**
```typescript
class AdvancedSimulationEngine {
  async simulateMultiplePaths(
    playbooks: Playbook[],
    alert: ECSAlert
  ): Promise<SimulationComparison> {

    const simulations = await Promise.all(
      playbooks.map(p => this.simulate(p, alert))
    )

    // Score each simulation
    const scored = simulations.map(sim => ({
      ...sim,
      score: this.calculateScore(sim),
      risks: this.identifyRisks(sim),
      benefits: this.identifyBenefits(sim)
    }))

    // Rank by score
    const ranked = scored.sort((a, b) => b.score - a.score)

    return {
      simulations: ranked,
      recommendation: ranked[0],
      reasoning: this.explainRecommendation(ranked)
    }
  }

  private calculateScore(sim: SimulationReport): number {
    return (
      sim.predictedOutcome === 'SUCCESS' ? 1.0 : 0.0 +
      (1 - sim.estimatedDuration / MAX_DURATION) * 0.5 +
      (1 - sim.risksIdentified.length / MAX_RISKS) * 0.3 +
      sim.confidence * 0.2
    )
  }
}
```

### 14.6 Playbook Marketplace

**Concept:** Community-contributed playbooks with validation and ratings.

**Features:**
- Public repository of vetted playbooks
- Automated testing and validation
- Community ratings and reviews
- Vendor-specific playbooks (CrowdStrike, Sentinel, etc.)
- Technique coverage matrix (ATT&CK heatmap)

**Architecture:**
```
runbookpilot marketplace search "ransomware"
runbookpilot marketplace install ransomware-containment-v2
runbookpilot marketplace publish my-playbook.yaml
runbookpilot marketplace validate my-playbook.yaml
```

---

## 15. Conclusion

RunbookPilot represents a pragmatic approach to SOC automation: safety-first, human-in-the-loop, and incrementally autonomous. By combining deterministic execution with AI assistance (not AI control), it enables SOC teams to respond faster without sacrificing oversight.

**Key Architectural Strengths:**
1. **Deterministic Core** - Predictable, auditable, reproducible
2. **Graduated Autonomy** - Start manual, scale to semi-auto, simulate full-auto
3. **Vendor Agnostic** - Works with any SIEM, EDR, or security tool
4. **Safety by Design** - Approval gates and rollback are mandatory, not optional
5. **DetectForge Synergy** - Detection-to-response pipeline in one ecosystem

**v1 Scope:**
- L0 manual checklists
- L1 semi-automated enrichment with approval-gated actions
- L2 simulation mode (no auto-execution)
- DetectForge integration
- 5 reference playbooks
- 3 EDR adapters (CrowdStrike, Sentinel, SentinelOne)
- CLI + Docker deployment

**Future Vision:**
- Living runbooks with performance optimization
- Selective auto-L2 execution based on confidence
- ML-powered decision support (non-blocking)
- Advanced multi-path simulation
- Community playbook marketplace
- Enterprise SSO integration
- Prometheus metrics export

This architecture provides a solid foundation for building RunbookPilot incrementally, validating each autonomy level before progressing, and maintaining security and auditability throughout.

---

**Document Version:** 1.0
**Status:** Approved for Implementation
**Next Review:** After S0 Sprint Completion